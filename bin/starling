#!/usr/bin/env python

"""
Implantation du répartiteur Starling.

Il est conçu pour être appelé par gammu-smsd avec la directive RunOnReceive. Il
extrait les données de Gammu de l’environnement et appelle le module Starling
qui va bien, puis réinjecte la réponse dans smsd pour l’envoyer par SMS.

Les modules sont situés dans le dossier modules/, qui doit exister au même
niveau que l’exécutable starling.
"""


import os
import re
import subprocess
import sys
import yaml


# Définit la taille maximum de la réponse. Ça correspond à 5 SMS en alphabet
# standard, ou bien 10 en SMS Unicode. Tout message plus long que ça sera
# tronqué.
MAX_SMS_LENGTH = 700


def read_sms():
    """
    Logique pour obtenir le contenu du SMS, reprise de l’exemple dans la
    documentation de gammu-smsd.
    """
    numparts = int(os.environ["DECODED_PARTS"])
    text = ""
    if numparts == 0:
        text = os.environ["SMS_1_TEXT"]
    else:
        for i in range(1, numparts + 1):
            varname = "DECODED_%d_TEXT" % i
            if varname in os.environ:
                text = text + os.environ[varname]
    return text


def extract_first_word(text):
    parts = text.split(maxsplit=1)
    if parts:
        return parts[0]
    else:
        return None


def find_module(command):
    """
    Renvoie le chemin vers un module Starling exécutable à partir d’un nom de
    commande, ou None si on ne trouve rien de convenable.

    Utilise le résultat de os.listdir comme liste blanche pour éviter qu’un
    rigolo passe `../evil-program` comme commande.
    """
    modules_dir = os.path.join(os.path.dirname(__file__), '..', 'modules')
    module_list = os.listdir(modules_dir)
    module_name = command.lower()
    if module_name not in module_list:
        return None

    module_path = os.path.join(modules_dir, module_name)
    if os.path.isfile(module_path):
        return module_path
    else:
        return None


def sanitize_message(text):
    """
    Transforme le message si nécessaire pour ne pas qu’il fasse exploser le
    modem téléphonique.
    """
    if len(text) > MAX_SMS_LENGTH:
        text = text[:MAX_SMS_LENGTH - 3] + '...'
    return text


def requires_unicode(text):
    """
    Indique si le texte passé vaut la peine d’être envoyé en tant qu’UTF-16,
    sachant que les SMS seront alors deux fois plus gros. Pour les blocs
    Unicode CJK, ça vaut le coup, mais pour les accents français rares
    peut-être pas.
    """
    return re.search("[\u2e80-\u9fff]", text) is not None


def send_sms(recipient, text):
    command_line = ['gammu-smsd-inject']
    gammu_config = os.environ.get('GAMMU_SMSD_CONFIG')
    if gammu_config:
        command_line.append('-c')
        command_line.append(gammu_config)
    command_line.append('--')
    command_line.append('TEXT')
    command_line.append(recipient)
    command_line.append('-autolen' if requires_unicode(text) else '-len')
    command_line.append(str(MAX_SMS_LENGTH))

    text = sanitize_message(text)
    subprocess.run(command_line, input=text, text=True, check=True)


def dispatch_sms(sender, text):
    """
    Extrait le premier mot du SMS et l’utilise pour invoquer le module Starling
    voulu, puis envoie la réponse à gammu-smsd-inject.
    """
    command = extract_first_word(text)
    if command is None:
        # Ignorer les SMS vides.
        return

    module = find_module(command)
    if module is None:
        print(f"Commande introuvable : {command}", file=sys.stderr)
        return

    os.environ['SENDER'] = sender
    result = subprocess.run([module], input=text, stdout=subprocess.PIPE,
                            text=True, check=True)
    response = result.stdout

    if response:
        send_sms(sender, response)


def check_sender(sender):
    """
    Vérifie que le numéro de l’expéditeur est connu, car on ne veut pas prendre
    le risque d’envoyer un SMS à un inconnu, ou bien à une boite automatique
    qui nous aurait envoyé de la pub. Les numéros sont normalement tous
    préfixés par un `+` suivi du code de pays.
    """
    with open('users.yml') as f:
        users = yaml.full_load(f)
    return sender in users


def main():
    sender = os.environ["SMS_1_NUMBER"]
    if check_sender(sender):
        text = read_sms()
        dispatch_sms(sender, text)
    else:
        print(f"Numéro inconnu : {sender}", file=sys.stderr)
    return 0


if __name__ == '__main__':
    sys.exit(main())
