#!/usr/bin/env python

"""
Module RATP pour obtenir les prochaines passages à un arrêt de bus ou de train.

La RATP expose une API SOAP pour obtenir les horaires en temps réel, voir
<https://data.ratp.fr/pages/temps-reel/>. Pour l’utiliser, il faut s’inscrire
auprès le la RATP en envoyant un formulaire PDF par mél, et avoir une IP fixe.

Quelqu’un de bien propose cependant une API REST beaucoup plus facile à
utiliser. Voir <https://github.com/pgrimaud/horaires-ratp-api>. C’est celle-ci
que ce module utilise.
"""


from collections import deque
from datetime import datetime, timedelta
import re
import requests
import sys
import unicodedata

import editdistance


USAGE = "Usage: ratp trafic | ratp (rer|bus|métro|tram) LIGNE ARRÊT"

# Traduit les types de ligne que notre module accepte en types normalisés pour
# l’API REST.
LINE_TYPES = {
    "bus": "buses",
    "métro": "metros",
    "metro": "metros",
    "tram": "tramways",
    "tramway": "tramways",
    "rer": "rers",
}

# Conversion entre les types de ligne utilisés dans l’API et quelque chose de
# plus humain.
LINE_NAMES = {
    "metros": "Métro",
    "rers": "RER",
    "tramways": "Tram",
}

# Ensemble des caractères qu’on autorise dans un nom de ligne. On suppose que
# les numéros de ligne ont déjà été normalisés en bas de casse.
SAFE_CHARACTERS = set("0123456789-abcdefghijklmnopqrstuvwxyz")

API_BASE = "https://api-ratp.pierre-grimaud.fr/v4"

TIME_REGEX = re.compile(r"(?P<time>\d+:\d+)")

DURATION_REGEX = re.compile(r"(?P<minutes>\d+)\s*mi?n")


class BadUsage(Exception):
    """
    Interrompt l’exécution du module avec une message qui sera envoyé par SMS à
    l’utilisateur, avec les instructions d’utilisation.
    """


def transliterate(text):
    """
    Simplifie le texte donné en enlevant les accents et caractères spéciaux.
    Normalise également le tout en bas de casse.
    """
    return (unicodedata.normalize('NFKD', text)
                       .encode('ascii', 'ignore')
                       .decode('ascii')
                       .lower())


def best_match(options, keywords, key=lambda x: x):
    """
    Parmi une liste d’option, trouve celle dont key(option) correspond le mieux
    aux mots-clés donnés. key(option) et chaque mot-clé doivent être des str.
    Voir find_stop pour le comportement global souhaité.
    """
    keywords = [transliterate(kw) for kw in keywords]
    query = " ".join(keywords)

    def matches_keywords(option):
        name = transliterate(key(option))
        return all(kw in name for kw in keywords)

    def distance(option):
        return editdistance.eval(transliterate(key(option)), query)

    candidates = list(filter(matches_keywords, options)) or options
    return min(candidates, key=distance)


def find_stop(line_type, line_code, stop_keywords):
    """
    Recherche l’arrêt le plus proche de ce que l’utilisateur voudrait à partir
    d’une liste de mots-clés entrés. On commence par chercher les arrêts qui
    contiennent les mots-clés, puis parmi les candidats on utilisera la
    distance de Levenshtein pour sélectionner le meilleur.

    En cas de faute de frappe, la recherche par infixe échouera et on comptera
    uniquement sur la distance de Levenshtein. Elle est moins souhaitable car
    rechercher « Saintt Michel » donnera par exemple « Le Guichet » alors qu’on
    préfèrerait clairement « Saint-Michel Notre-Dame ».

    Renvoie un dico avec les clés *name* et *slug*, par exemple :
    `{ "name": "Porte des Lilas", "slug": "porte+des+lilas" }`
    """
    r = requests.get(f"{API_BASE}/stations/{line_type}/{line_code}")
    if r.status_code != 200:
        raise BadUsage("Ligne invalide.")

    stops = r.json()["result"]["stations"]
    if not stops:
        raise BadUsage("Aucun arrêt trouvé.")

    return best_match(stops, stop_keywords, key=lambda stop: stop["name"])


def print_schedules(json):
    """
    Formate et affiche une réponse API sur les prochains passage d’une ligne à
    un arrêt.
    """
    for schedule in json["result"]["schedules"]:
        time = "--:--"

        # Les bus, trams et métros affichent des messages comme « 3 mn ».
        if m := DURATION_REGEX.search(schedule["message"]):
            wait = int(m.group("minutes"))
            time = (datetime.now() + timedelta(minutes=wait)).strftime("%H:%M")

        # Les RER affichent des messages comme « 19:05 Voie 1 ».
        if m := TIME_REGEX.search(schedule["message"]):
            time = m.group("time")

        destination = schedule.get("code") or schedule["destination"]
        print(f"{time} {destination}")


def show_schedules(line_type, line_code, stop_code):
    """
    Consulte et affiche les horaires pour un arrêt d’une ligne donné. Il faut
    faire 2 requêtes : un pour la direction aller, et l’autre pour la direction
    retour. Même en cas d’erreur on obtient un 200, donc on se contente
    d’afficher bêtement ce qu’on récupère.

    Si la réponse a un format inattendu, ou bien que l’API plante pour X
    raison, on aura une erreur dans les journaux, mais aucun SMS ne sera émis.
    """
    base_url = f"{API_BASE}/schedules/{line_type}/{line_code}/{stop_code}"

    forth = requests.get(f"{base_url}/A")
    forth.raise_for_status()

    back = requests.get(f"{base_url}/R")
    back.raise_for_status()

    print_schedules(forth.json())
    print()
    print_schedules(back.json())


def show_traffic():
    """
    Consulte et affiche les informations trafic RATP. Les lignes sans incident,
    ou avec des travaux mais rien ne de plus sont omises de le réponse pour ne
    pas charger inutilement le SMS.

    Si tout le réseau est vert, on répond quand même quelque chose pour ne pas
    laisser croire que la commande plante.
    """
    r = requests.get(f"{API_BASE}/traffic")
    r.raise_for_status()

    all_ok = True

    for line_type, lines in r.json()["result"].items():
        line_name = LINE_NAMES[line_type]
        for line in lines:
            if line["slug"] in ["normal", "normal_trav"]:
                continue
            if all_ok:
                all_ok = False
            else:
                print()  # Séparateur.
            print(f"{line_name} {line['line']} : {line['title']}")
            print(line['message'])

    if all_ok:
        print('Rien à signaler.')


def run(args):
    """
    Extrait les informations du SMS de l’utilisateur et fait l’action demandée.
    """
    args = deque(args)
    if len(args) < 2:
        raise BadUsage("Arguments manquant.")

    args.popleft()  # Nom de la commande.

    subcommand = args.popleft().lower()
    if subcommand in ["trafic", "traffic"]:
        show_traffic()
        return

    line_type = LINE_TYPES.get(subcommand)
    if not line_type:
        raise BadUsage("Type de ligne non reconnu.")

    # On est ici dans le cas où on cherche les prochains passage.
    # Il doit nous rester deux arguments : la ligne et l’arrêt.
    if len(args) < 2:
        raise BadUsage("Arguments manquant.")

    line_code = args.popleft().lower()
    if not set(line_code).issubset(SAFE_CHARACTERS):
        raise BadUsage("Numéro de ligne invalide.")

    # Concatène tous les arguments restants pour former le nom de l’arrêt.
    stop = find_stop(line_type, line_code, args)
    print(f"Arrêt {stop['name']}")
    print()

    show_schedules(line_type, line_code, stop["slug"])


def main():
    try:
        run(sys.stdin.read().split())
    except BadUsage as e:
        print(e)
        print(USAGE)
        return 0


if __name__ == "__main__":
    sys.exit(main())
